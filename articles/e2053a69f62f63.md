---
title: "Node.jsを理解する (V8)"
emoji: "🦔"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [nodejs, v8]
published: false
---

# はじめに

![Node.jsのアーキテクチャの図](https://user-images.githubusercontent.com/51479834/175769570-5c86b34d-f406-412c-b3d1-10afc9522413.png)

[前回の記事](https://zenn.dev/mmomm/articles/ff83eb49a7b642)で上記の Node.js のアーキテクチャにおける `libuv` の部分についてまとめました。
今回はその隣にある `V8` について書いていきます。

# おことわり

- Parse と Compile の詳細な話はしません。
- Web Assembly の話はしないので liftoff の話はしません。
- できるだけ一次情報を参照するようにしていますが、間違っている箇所がある可能性があります。

# V8 とは

V8 とは JavaScript 実行エンジンの一つで Google が作成したものであり、Node.js と Chromium などの一部のブラウザが使用しています、他の JavaScript 実行エンジンとしては SpiderMonkey などがあります。

JavaScript はインタープリタ型言語なのでコードを解釈して実行するためのエンジンが必要ですが、V8 は JavaScript を解釈しネイティブのマシンコードに変換すると言う役割を担っています。

:::message
この記事ではブラウザ側の話はしません。
:::

V8 は C++で書かれていて、ECMAScript と WebAssembly を実装しています、ECMAScript が実装されているので最低限の WebAPI が実装されているので Node.js の層まで行かなくてもある程度の API は実行することができます。
実装されている API は[main/include 配下](https://github.com/v8/v8/tree/main/include)にあります。

V8 はスタンドアロンで実行することもできるほか、C++のアプリケーションで使用することも可能です。

V8 が行っていることとしては公式より

> V8 compiles and executes JavaScript source code, handles memory allocation for objects, and garbage collects objects it no longer needs. V8’s stop-the-world, generational, accurate garbage collector is one of the keys to V8’s performance.
>
> V8 は JavaScript のソースコードをコンパイルして実行し、オブジェクトのメモリ割り当てを行い、不要になったオブジェクトをガベージコレクタで回収します。V8 の Stop-the-World, Generational, accurate garbage collector は、V8 のパフォーマンスの鍵の 1 つです。

簡単に言うと、V8 の行っていることはソースコードの変換とメモリ管理です。
`Call Stack Execution Context` はちょっと怪しいですが、下の図の左側がメモリの話で右側がソースコードの変換の話です。

![V8のアーキテクチャ図](https://user-images.githubusercontent.com/51479834/175797940-b15c3ca7-a101-49b2-b5bb-642745e6f9a3.png)

# メモリの話

JavaScript はシングルスレッドな言語なので V8 も JavaScript のコンテキスト毎に一つのプロセスを使用しています。
実行中のプログラムは、常に V8 プロセス内に割り当てられたメモリによって表現され、これを `Resident Set(常駐セット)` と呼びます。これはさらに以下のように異なるセグメントに分割されます。

基本的なメモリ領域として `Stack` と `Heap` があります、もちろん V8 も例外ではなく `Stack(CallStack)` `Heap` を使用してメモリ管理を行なっています。
V8 のメモリ管理は以下の図のようになっています。
![V8のメモリ管理の図](https://user-images.githubusercontent.com/51479834/175837963-dc9a2dc2-ab7d-4b44-b474-0e9fbdf470f9.png)

# Stack(CallStack) Memory

スタックにはメソッド/ファンクションフレーム、プリミティブな値、オブジェクトへのポインタなどの静的データが格納されます。
スタックメモリの上限は --stack_size V8 フラグで設定することができます。
スタックは OS によって管理されており、不要になったスタックのデータは自動で削除されます。

# Heap Memory

スタックと異なり動的なデータはヒープに格納されます、具体的にはメソッドやファンクションの型・値はヒープに格納され、スタックポインタを使用してスタックから参照されます。
処理が完了するとスタックは OS によって自動的に管理されるため、ヒープ上のオブジェクトはスタックからの参照がなくなり孤立します。
しかしヒープは自動で管理されておらず、動的なデータを保持するため、指数関数的に増大し、時間の経過と共にプログラムがメモリ不足になる可能性があります。
つまり、スタックから直接または間接的に（他のオブジェクトの参照を通じて）参照されなくなったオブジェクトを新しいオブジェクトの生成のために解放します。
JavaScript には `free()` のように明示的にメモリを解放する方法は提供されていないので `GC(Garbage Collector)` が働いており、必要のなくなったヒープメモリは GC が回収します。V8 では `Orinoco` という GC が使用されています。

ヒープメモリの全てが GC の対象になるわけではなくヤングスペースとオールドスペースだけが GC で管理されます。

# v8 のメモリ使用

@[speakerdeck](e89e2e48a797417eb8692897dcada584)

# Orinoco

GC ではヒープ上のポインタとデータを区別することが重要ですが、V8 ではこのために「タグ付きポインタ」アプローチを採用しています。
このアプローチは、コンパイラのサポートが限定的ですが、かなり効率的であると同時に実装が簡単です。
Orinoco は V8 で使用されている GC プロジェクトのコードネームで、GC に並列・漸進・並行技術を利用し、メインスレッドを解放するためのものです。

V8 の GC(Orinoco)には MajorGC と MinorGC があります。
MajorGC は Mark-Sweep-Compact アルゴリズム、MinorGC は Scavenger アルゴリズムが使用されています。
どちらもやっていることとしては使われなくなったヒープメモリをマークして回収して圧縮してメモリ割り当てを効率化することをおこなっており
どちらも stop-the-world するけど MinorGC による停止時間は無視できるほど小さくて、MajorGC が走る時もヘルパースレッドを使いできるだけメインスレッドをブロッキングしないようにしてる

差分としては

> Scavenger アルゴリズムは小さいデータサイズには最適ですが、ヒープが大きい場合はメモリオーバーとなるため実用的ではありません。

# ソースコードの変換の話

V8 はインタープリタとコンパイラを持っており、改善をおこなってきていました。
インタープリタは JIT コンパイラに変更されています。
インタープリタは全てのコードを逐次機械語に変換するものですが、
JIT コンパイラ(Just in time compiler)は機械語ではなくバイトコードに変換し、バイトコードを実行している間に他のコンパイラが全体のパフォーマンスを向上させるために最適化できるコードを特定します、特定が完了するとバイトコードの一部から最適化された機械語を生成し、そのバイトコードの一部を最適化された機械語のコードに置き換え、それ以降、その箇所を実行する際に最適化された機械語のコードを使用するようにします。
この動作によって、V8 に読み込まれている JavaScript コードの実行速度は最適化された箇所が増加するのに応じて徐々に改善していきます。
この特徴があるために V8 はインタープリタではなく JIT コンパイラを採用しています。

大きく分けて

1. Full-Codegen + Craftshake
2. Ignition + Craftshake
3. Ignition + TurboFan
   の時期があります。

現在は JIT コンパイラが `Ignition` 、コンパイラが `TurboFan` です。(Full-Codegen が JIT コンパイラ、Craftshake がコンパイラ)
メモリの使用量やパース・コンパイル処理にかかる時間が大きく削減されました。

# Ignition

V8 の内部では `Ignition` という JIT コンパイラが使用されています。
Ignition は TurboFan のバックエンドを使用して書かれた高速な低レベル・レジスタベースの JIT コンパイラです。
Ignition は JavaScript を機械語ではなくバイトコードに変換します。
このコンパイルは高速なだけでなく、結果として得られるバイトコードは機械語よりもはるかにコンパクトで、メモリ効率が向上します（モバイルデバイスでは特に重要です）。このバイトコードは、高性能なインタプリタによって実行され、JIT で生成された機械語に近い実行速度が得られます。

# Turbofan

V8 の内部では `Turbofan` というコンパイラが使用されています。
TurboFan は `Sea of Nodes` と呼ばれる概念を活用した V8 の最適化コンパイラの一つです。

JIT が行っている最適化で主に挙げられるものとして **Hidden Class** 、 **Inline Caches** があります。

## Hidden Class

これはオブジェクトにプロパティが追加された際に重複したオブジェクトを作成しないために V8 が内部で作成しているものです。
Java などのコンパイル言語ではオブジェクトのすべてのプロパティはコンパイル前に固定されたオブジェクトレイアウトによって決定され、実行時に動的に追加/削除することはできません。
そのためプロパティの型に基づいてオフセットの長さを簡単に決定することができます
しかしプロパティの型が実行中に変更される可能性がある Javascript では、このようなことは不可能です。

メモリにあるオブジェクトプロパティのロケーションを見つけるために連想配列を使うことは非常に非効率なので JavaScript では Hidden Class という手法を使用しています。

例えば以下のようなコードが生成された際に `C0` という名前のついた Hidden Class が生成されます。

```js
const obj = {};
```

ここに新しくプロパティが追加されると `C1` という Hidden Class が作られます。
a というオフセットをこの C1 は持っており、C0 は `C0にaというプロパティが追加された際にC1にtransition` するという情報が入る。

```js
obj.a = 1;
```

さらに C1 に対して新たにプロパティが追加されると `C2` という Hidden Class が作られます。
そうするとまた同じように C2 は b というオフセットを持っており、C1 は `C1にbというプロパティが追加された際にC2にtransition` するという情報が入る。

```js
obj.b = 2;
```

上記したようにプロパティが追加された順に Hidden Class は情報を数珠繋ぎで持っています。
上記は簡単な例ですが、できるだけ共通化して Hidden Class の情報を保持しておくために `DescriptorArray` と `TransitionArray` があります。
`Transition Array` は

::: message
以下 V8 の公式ドキュメントを参照します
:::

```js
function Peak(name, height, extra) {
  this.name = name;
  this.height = height;
  if (isNaN(extra)) {
    this.experience = extra;
  } else {
    this.prominence = extra;
  }
}

m1 = new Peak("Matterhorn", 4478, 1040);
m2 = new Peak("Wendelstein", 1838, "good");
m2.cost = "hello";
```

このような Peak 関数があります。
今の構造を図に起こすと以下のような感じになります。
![a](https://user-images.githubusercontent.com/51479834/177229388-21319db0-aa63-4d4d-8d22-f8efba757a9d.png)

この図に `DescriptorArray` を追加すると以下の図のようになります。

![b]()

Map1、Map2、Map3 が `DescriptorArray1` を指しています、それぞれの Map の `descriptors` のフィールドの数字は DescriptorArray の幾つのフィールドがその Map に所属しているかを表しています。
name プロパティしか知らない Map1 は DescriptorArray1 内にリストされた最初のプロパティだけを見ることになります。
一方、Map2 は `name` と `height` という 2 つのプロパティを持っています。そのため、DescriptorArray1 の 1 番目と 2 番目の項目（name と height）を見ることになります。

Map2 から Map3、Map4 に移行するときに TransitionArray が存在しています。
それぞれの Map の `transitions` のフィールドの数字は TransitionArray のどのフィールドがその Map に所属しているかを表しています。
そして必要なものだけを取得します。

このように共有することで、Hidden Class を作成する際にかなりの容量を節約することができます。
これを行うことで同じ順番や同じプロパティを参照した時に無駄な Hidden Class を作らないようにしています。

名前つきプロパティには `In-object` `Fast dictionary` `slow dictionary` の三種類があります。
オブジェクト内プロパティは、オブジェクト自体に直接格納され、最も高速なアクセスを提供します。
fast dictionary はプロパティ ストアに格納され、すべてのメタ情報は HiddenClass 上の記述子配列に格納されます。
slow dictionary は、自己完結型のプロパティ・ディクショナリに格納され、HiddenClass を通してメタ情報が共有されることはありません。
slow dictionary は、プロパティの削除と追加を効率的に行うことができますが、他の 2 つのタイプよりもアクセス速度が遅くなります。

## Inline Caches

インライン・キャッシングは、あるメソッド呼び出しが繰り返し発生する状況というのが、同じ型のオブジェクトに起こりがちであるという観測に基づいています。
V8 は、最も最近呼び出されたメソッドに渡されたオブジェクトの型のキャッシュを管理し、この情報を将来パラメータとして通過するであろうオブジェクトの型を推測するのに活用します。V8 がメソッドに追加するオブジェクトの型をほぼ正しく推測することができれば、オブジェクトのプロパティへのアクセス方法を突き止めるプロセスを省くことができ、直前のオブジェクトの hidden class の検索から得た記録情報を使うことができます。

上記した Hidden Class は Inline Caches で使用されています。
特定のオブジェクト上でメソッドが呼び出されるときはいつも、V8 エンジンは特定のプロパティにアクセスするためのオフセットを断定するために、特定オブジェクトの hidden class を検索しなくてはなりません。
同じ hidden class に対して同じメソッドの呼び出しがうまくいくと、V8 は hidden class の検索を省略し、単にオブジェクトポインタに対しプロパティのオフセットを追加します。
今後このメソッドに対して呼び出しが行われる場合、V8 エンジンは hidden class は変更されていないと推測し、直前の検索で保存されたオフセットを使って、特定のプロパティのメモリアドレスに直接移動します。これにより実行速度が一段と向上します。

## 最適化に優しい書き方

上記したようにオブジェクトのプロパティ間のオフセットの計算を削除し、オブジェクトのプロパティへのアクセスを最適化するために Hidden Class というものが使用されています。
これは全く同じオブジェクトであっても、プロパティの定義の順番が異なるだけで複数の Hidden Class が作成されてしまうなどの問題があります。
そこで最大限にこの機能を活かすために

1. オブジェクトプロパティは常に同じ順番でインスタンス化し、無駄な Hidden Class を生成しないこと
2. インスタンス化後にプロパティを追加すると Hidden Class が変更され、以前の Hidden Class 用に最適化されていたメソッドの速度が低下するため、オブジェクトのすべてのプロパティをそのコンストラクタで割り当てる。
3. 同じメソッドを繰り返し実行するコードは、多くの異なるメソッドを一度だけ実行するコードよりも高速に実行されるため、できるだけ同じメソッドを使用する実装を心がける。

# まとめ

# 参考資料

- https://v8.dev/docs/hidden-classes
- https://v8.dev/blog/fast-properties
