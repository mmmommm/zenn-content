---
title: "Node.jsを理解する (V8)"
emoji: "🦔"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [nodejs, v8]
published: false
---

# はじめに
![Node.jsのアーキテクチャの図](https://user-images.githubusercontent.com/51479834/175769570-5c86b34d-f406-412c-b3d1-10afc9522413.png)

[前回の記事](https://zenn.dev/mmomm/articles/ff83eb49a7b642)で上記のNode.jsのアーキテクチャにおける `libuv` の部分についてまとめました。
今回はその隣にある `V8` について書いていきます。

# お断り
- ParseとCompileの詳細な話はしません。
- できるだけ一次情報を参照するようにしていますが、間違っている箇所がある可能性があります。

# V8とは
V8とはJavaScript実行エンジンの一つでGoogleが作成したものであり、Node.jsとChromiumなどの一部のブラウザが使用しています、他のJavaScript実行エンジンとしてはSpiderMonkeyなどがあります。

JavaScriptはインタープリタ型言語なのでコードを解釈して実行するためのエンジンが必要ですが、V8はJavaScriptを解釈しネイティブのマシンコードに変換すると言う役割を担っています。

:::message
この記事ではブラウザ側の話はしません。
:::

V8はC++で書かれていて、ECMAScriptとWebAssemblyを実装しています、ECMAScriptが実装されているので最低限のWebAPIが実装されているのでNode.jsの層まで行かなくてもある程度のAPIは実行することができます。
実装されているAPIは[main/include配下](https://github.com/v8/v8/tree/main/include)にあります。

V8はスタンドアロンで実行することもできるほか、C++のアプリケーションで使用することも可能です。

V8が行っていることとしては公式より
>V8 compiles and executes JavaScript source code, handles memory allocation for objects, and garbage collects objects it no longer needs. V8’s stop-the-world, generational, accurate garbage collector is one of the keys to V8’s performance.
>
>V8はJavaScriptのソースコードをコンパイルして実行し、オブジェクトのメモリ割り当てを行い、不要になったオブジェクトをガベージコレクタで回収します。V8のStop-the-World, Generational, accurate garbage collectorは、V8のパフォーマンスの鍵の1つです。

簡単に言うと、V8の行っていることはソースコードの変換とメモリ管理です。
`Call Stack Execution Context` はちょっと怪しいですが、下の図の左側がメモリの話で右側がソースコードの変換の話です。

![V8のアーキテクチャ図](https://user-images.githubusercontent.com/51479834/175797940-b15c3ca7-a101-49b2-b5bb-642745e6f9a3.png)

# メモリの話

JavaScriptはシングルスレッドな言語なのでV8もJavaScriptのコンテキスト毎に一つのプロセスを使用しています。
実行中のプログラムは、常にV8プロセス内に割り当てられたメモリによって表現され、これを `Resident Set(常駐セット)` と呼びます。これはさらに以下のように異なるセグメントに分割されます。

基本的なメモリ領域として `Stack` と `Heap` があります、もちろんV8も例外ではなく `Stack(CallStack)` `Heap` を使用してメモリ管理を行なっています。
V8のメモリ管理は以下の図のようになっています。
![V8のメモリ管理の図](https://user-images.githubusercontent.com/51479834/175837963-dc9a2dc2-ab7d-4b44-b474-0e9fbdf470f9.png)

# Stack(CallStack) Memory
スタックにはメソッド/ファンクションフレーム、プリミティブな値、オブジェクトへのポインタなどの静的データが格納されます。
スタックメモリの上限は --stack_size V8フラグで設定することができます。
スタックはOSによって管理されており、不要になったスタックのデータは自動で削除されます。

# Heap Memory
スタックと異なり動的なデータはヒープに格納されます、具体的にはメソッドやファンクションの型・値はヒープに格納され、スタックポインタを使用してスタックから参照されます。
処理が完了するとスタックはOSによって自動的に管理されるため、ヒープ上のオブジェクトはスタックからの参照がなくなり孤立します。
しかしヒープは自動で管理されておらず、動的なデータを保持するため、指数関数的に増大し、時間の経過と共にプログラムがメモリ不足になる可能性があります。
つまり、スタックから直接または間接的に（他のオブジェクトの参照を通じて）参照されなくなったオブジェクトを新しいオブジェクトの生成のために解放します。
JavaScriptには `free()` のように明示的にメモリを解放する方法は提供されていないので `GC(Garbage Collector)` が働いており、必要のなくなったヒープメモリはGCが回収します。V8では `Orinoco` というGCが使用されています。


ヒープメモリの全てがGCの対象になるわけではなくヤングスペースとオールドスペースだけがGCで管理されます。

# v8のメモリ使用
@[speakerdeck](e89e2e48a797417eb8692897dcada584)

# Orinoco
GCではヒープ上のポインタとデータを区別することが重要ですが、V8ではこのために「タグ付きポインタ」アプローチを採用しています。
このアプローチは、コンパイラのサポートが限定的ですが、かなり効率的であると同時に実装が簡単です。
OrinocoはV8で使用されているGCプロジェクトのコードネームで、GCに並列・漸進・並行技術を利用し、メインスレッドを解放するためのものです。

V8のGC(Orinoco)にはMajorGCとMinorGCがあります。
MajorGCはMark-Sweep-Compactアルゴリズム、MinorGCはScavengerアルゴリズムが使用されています。
どちらもやっていることとしては使われなくなったヒープメモリをマークして回収して圧縮してメモリ割り当てを効率化することをおこなっており
どちらも stop-the-worldするけどMinorGCによる停止時間は無視できるほど小さくて、MajorGCが走る時もヘルパースレッドを使いできるだけメインスレッドをブロッキングしないようにしてる

差分としては
>Scavengerアルゴリズムは小さいデータサイズには最適ですが、ヒープが大きい場合はメモリオーバーとなるため実用的ではありません。

# ソースコードの変換の話

V8はインタープリタとコンパイラを持っており、改善をおこなってきていました。
インタープリタはJITコンパイラに変更されています。
インタープリタは全てのコードを逐次機械語に変換するものですが、
JITコンパイラ(Just in time compiler)は機械語ではなくバイトコードに変換し、バイトコードを実行している間に他のコンパイラが全体のパフォーマンスを向上させるために最適化できるコードを特定します、特定が完了するとバイトコードの一部から最適化された機械語を生成し、そのバイトコードの一部を最適化された機械語のコードに置き換え、それ以降、その箇所を実行する際に最適化された機械語のコードを使用するようにします。
この動作によって、V8に読み込まれているJavaScriptコードの実行速度は最適化された箇所が増加するのに応じて徐々に改善していきます。
この特徴があるためにV8はインタープリタではなくJITコンパイラを採用しています。

大きく分けて
1. Full-Codegen + Craftshake
2. Ignition + Craftshake
3. Ignition + TurboFan
の時期があります。

現在はJITコンパイラが `Ignition` 、コンパイラが `TurboFan` です。(Full-CodegenがJITコンパイラ、Craftshakeがコンパイラ)
メモリの使用量やパース・コンパイル処理にかかる時間が大きく削減されました。

# Ignition
V8の内部では `Ignition` というJITコンパイラが使用されています。
IgnitionはTurboFanのバックエンドを使用して書かれた高速な低レベル・レジスタベースのJITコンパイラです。
IgnitionはJavaScriptを機械語ではなくバイトコードに変換します。
このコンパイルは高速なだけでなく、結果として得られるバイトコードは機械語よりもはるかにコンパクトで、メモリ効率が向上します（モバイルデバイスでは特に重要です）。このバイトコードは、高性能なインタプリタによって実行され、JITで生成された機械語に近い実行速度が得られます。
# Turbofan
V8の内部では `Turbofan` というコンパイラが使用されています。
TurboFanは `Sea of Nodes` と呼ばれる概念を活用したV8の最適化コンパイラの一つです。

JITが行っている最適化で主に挙げられるものとして **Hidden Class** 、 **Inline Caches** があります。
## Hidden Class
これはオブジェクトにプロパティが追加された際に重複したオブジェクトを作成しないためにV8が内部で作成しているものです。
Javaなどはコンパイラー言語なのでオブジェクトのすべてのプロパティは、コンパイル前に固定されたオブジェクトレイアウトによって決定され、実行時に動的に追加/削除することはできません。そのためプロパティの型に基づいてオフセットの長さを簡単に決定することができます
しかしプロパティの型が実行中に変更される可能性があるJavascriptでは、このようなことは不可能です。

メモリにあるオブジェクトプロパティのロケーションを見つけるために辞書を使うことは非常に非効率なのでJavaScriptではHidden Classという手法を使用しています。

例えば以下のようなコードが生成された際に `C0` という名前のついたHidden Classが生成される。

```js
const obj = {};
```

ここに新しくプロパティが追加されると `C1` というHidden Classが作られる。
aというオフセットをこのC1は持っており、C0は `C0にaというプロパティが追加された際にC1にtransition` するという情報が入る。

```js
obj.a = 1;
```

さらにC1に対して新たにプロパティが追加されると `C2` というHidden Classが作られる。
そうするとまた同じようにC2はbというオフセットを持っており、C1は `C1にbというプロパティが追加された際にC2にtransition` するという情報が入る。

```js
obj.b = 2;
```

上記したようにプロパティが追加された順にHidden Classは情報を数珠繋ぎで持っている。
これを行うことで同じ順番や同じプロパティを参照した時に無駄なHidden Classを作らないようにしている。

## Inline Caches
インライン・キャッシングは、あるメソッド呼び出しが繰り返し発生する状況というのが、同じ型のオブジェクトに起こりがちであるという観測に基づいています。
V8は、最も最近呼び出されたメソッドに渡されたオブジェクトの型のキャッシュを管理し、この情報を将来パラメータとして通過するであろうオブジェクトの型を推測するのに活用します。V8がメソッドに追加するオブジェクトの型をほぼ正しく推測することができれば、オブジェクトのプロパティへのアクセス方法を突き止めるプロセスを省くことができ、直前のオブジェクトのhidden classの検索から得た記録情報を使うことができます。

上記したHidden ClassはInline Cachesで使用されています。
特定のオブジェクト上でメソッドが呼び出されるときはいつも、V8エンジンは特定のプロパティにアクセスするためのオフセットを断定するために、特定オブジェクトのhidden classを検索しなくてはなりません。
同じhidden classに対して同じメソッドの呼び出しがうまくいくと、V8はhidden classの検索を省略し、単にオブジェクトポインタに対しプロパティのオフセットを追加します。
今後このメソッドに対して呼び出しが行われる場合、V8エンジンはhidden classは変更されていないと推測し、直前の検索で保存されたオフセットを使って、特定のプロパティのメモリアドレスに直接移動します。これにより実行速度が一段と向上します。

## 最適化に優しい書き方
上記したようにオブジェクトのプロパティ間のオフセットの計算を削除し、オブジェクトのプロパティへのアクセスを最適化するためにHidden Classというものが使用されています。
これは全く同じオブジェクトであっても、プロパティの定義の順番が異なるだけで複数のHidden Classが作成されてしまうなどの問題があります。
そこで最大限にこの機能を活かすために

1. オブジェクトプロパティは常に同じ順番でインスタンス化し、無駄なHidden Classを生成しないこと
2. インスタンス化後にプロパティを追加するとHidden Classが変更され、以前のHidden Class用に最適化されていたメソッドの速度が低下するため、オブジェクトのすべてのプロパティをそのコンストラクタで割り当てる。
3. 同じメソッドを繰り返し実行するコードは、多くの異なるメソッドを一度だけ実行するコードよりも高速に実行されるため、できるだけ同じメソッドを使用する実装を心がける。
# まとめ
# 参考資料
