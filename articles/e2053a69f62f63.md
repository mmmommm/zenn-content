---
title: "Node.jsを理解する (V8)"
emoji: "🦔"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [nodejs, v8]
published: false
---

# はじめに
![Node.jsのアーキテクチャの図](https://user-images.githubusercontent.com/51479834/175769570-5c86b34d-f406-412c-b3d1-10afc9522413.png)

[前回の記事](https://zenn.dev/mmomm/articles/ff83eb49a7b642)で上記のNode.jsのアーキテクチャにおける `libuv` の部分についてまとめました。
今回はその隣にある `V8` について書いていきます。

# V8とは
V8とはJavaScript実行エンジンの一つでGoogleが作成したものであり、Node.jsとChromiumなどの一部のブラウザが使用しています、他のJavaScript実行エンジンとしてはSpiderMonkeyなどがあります。

JavaScriptはインタープリタ型言語なのでコードを解釈して実行するためのエンジンが必要ですが、V8はJavaScriptを解釈しネイティブのマシンコードに変換すると言う役割を担っています。

:::message
この記事ではブラウザ側の話はしません。
:::

V8はC++で書かれていて、ECMAScriptとWebAssemblyを実装しています、ECMAScriptが実装されているので最低限のWebAPIが実装されているのでNode.jsの層まで行かなくてもある程度のAPIは実行することができます。
実装されているAPIは[main/include配下](https://github.com/v8/v8/tree/main/include)にあります。

V8はスタンドアロンで実行することもでき、またC++のアプリケーションで使用することも可能です。

V8が行っていることとしては公式より
>V8 compiles and executes JavaScript source code, handles memory allocation for objects, and garbage collects objects it no longer needs. V8’s stop-the-world, generational, accurate garbage collector is one of the keys to V8’s performance.
>
>V8はJavaScriptのソースコードをコンパイルして実行し、オブジェクトのメモリ割り当てを行い、不要になったオブジェクトをガベージコレクタで回収します。V8のStop-the-World, Generational, accurate garbage collectorは、V8のパフォーマンスの鍵の1つです。

![V8のアーキテクチャ図](https://user-images.githubusercontent.com/51479834/175797940-b15c3ca7-a101-49b2-b5bb-642745e6f9a3.png)

JavaScriptはシングルスレッドな言語なのでV8もJavaScriptのコンテキスト毎に一つのプロセスを使用しています。
実行中のプログラムは、常にV8プロセス内に割り当てられたメモリによって表現され、これを `Resident Set(常駐セット)` と呼びます。これはさらに以下のように異なるセグメントに分割されます。

基本的なメモリ領域として `Stack` と `Heap` があります、もちろんV8も例外ではなく `Stack(CallStack)` `Heap` を使用してメモリ管理を行なっています。
V8のメモリ管理は以下の図のようになっています。
![V8のメモリ管理の図](https://user-images.githubusercontent.com/51479834/175837963-dc9a2dc2-ab7d-4b44-b474-0e9fbdf470f9.png)

# Stack(CallStack) Memory
スタックにはメソッド/ファンクションフレーム、プリミティブな値、オブジェクトへのポインタなどの静的データが格納されます。
スタックメモリの上限は --stack_size V8フラグで設定することができます。
スタックはOSによって管理されており、不要になったスタックのデータは自動で削除されます。

# Heap Memory
スタックと異なり動的なデータはヒープに格納されます、具体的にはメソッドやファンクションの型・値はヒープに格納され、スタックポインタを使用してスタックから参照されます。
処理が完了するとスタックはOSによって自動的に管理されるため、ヒープ上のオブジェクトはスタックからの参照がなくなり孤立します。
しかしヒープは自動で管理されておらず、動的なデータを保持するため、指数関数的に増大し、時間の経過と共にプログラムがメモリ不足になる可能性があります。
つまり、スタックから直接または間接的に（他のオブジェクトの参照を通じて）参照されなくなったオブジェクトを新しいオブジェクトの生成のために解放します。
JavaScriptには `free()` のように明示的にメモリを解放する方法は提供されていないので `GC(Garbage Collector)` が働いており、必要のなくなったヒープメモリはGCが回収します。V8では `Orinoco` というGCが使用されています。


ヒープメモリの全てがGCの対象になるわけではなくヤングスペースとオールドスペースだけがGCで管理されます。

# v8のメモリ使用
@[speakerdeck](e89e2e48a797417eb8692897dcada584)

# Orinoco
GCではヒープ上のポインタとデータを区別することが重要ですが、V8ではこのために「タグ付きポインタ」アプローチを採用しています。
このアプローチは、コンパイラのサポートが限定的ですが、かなり効率的であると同時に実装が簡単です。
OrinocoはV8で使用されているGCプロジェクトのコードネームで、GCに並列・漸進・並行技術を利用し、メインスレッドを解放するためのものです。

# Ignition
V8の内部では `Ignition` というインタープリタが使用されています。
# Turbofan
V8の内部では `Turbofan` というJITコンパイラが使用されています。



# まとめ
# 参考資料
