---
title: "k8s.io/apimachinery/pkg/util/wait ã®ä½¿ã„é“"
emoji: "ğŸ‘‹"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Go", "Kubernetes"]
published: false
---

wait ãŒä¾¿åˆ©ãªã®ã§ä½¿ã„ã¾ã—ã‚‡ã†ï¼

https://pkg.go.dev/k8s.io/apimachinery/pkg/util/wait

Kubernetes ã«é–¢é€£ã™ã‚‹é–‹ç™ºã‚’è¡Œã£ã¦ã„ã‚‹ã¨ Reconcile ã§å®Ÿè¡Œã•ã‚Œã‚‹å‡¦ç†ã‚’å¾…ã¤å¿…è¦ãŒã‚ã‚‹ã‚±ãƒ¼ã‚¹ãŒã‚ˆãã‚ã‚Šã¾ã™ã€‚
ãã®éš›ã« `wait` ã‚’ä½¿ã„ã¾ã™ã€‚

Overview ã«ã‚‚ä»¥ä¸‹ã®ã‚ˆã†ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€Condition ã®å¤‰æ›´ã‚’ polling / listening ã™ã‚‹ãŸã‚ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã™ã€‚

>Package wait provides tools for polling or listening for changes to a condition.

åŸºæœ¬çš„ã« wait ã¯ backoff ã‚’è¡Œã†ãŸã‚ã®é–¢æ•°ã¨ polling è¡Œã†ãŸã‚ã®é–¢æ•°ã«åˆ†ã‹ã‚Œã¦ã„ã¾ã™ã€‚

# Polling

Polling ã¯ç°¡å˜ã«ã„ã†ã¨ä¸€å®šé–“éš”ã§ä½•ã‹ã®çŠ¶æ…‹ã‚’ç¢ºèªã—ç¶šã‘ã‚‹ã“ã¨ã§ã™ã€‚
condition ãŒ true ã«ãªã‚‹ã¾ã§å¾…ã¡ç¶šã‘ã‚‹ç„¡é™ãƒ«ãƒ¼ãƒ—ã¿ãŸã„ãªã‚‚ã®ã§ã™ã€‚
å®Ÿéš›ã®ä¾‹ã ã¨ Pod ãŒ Running ã«ãªã‚‹ã¾ã§å¾…ã¤ã¿ãŸã„ãªã“ã¨ã«ãªã‚Šã¾ã™ã€‚

```go
for {
  if condition {
    break // finish polling
  }
  time.Sleep(5 * time.Second) // wait 5 sec and retry
}
```

## PollUntilContextCancel

```go
func PollUntilContextCancel(ctx context.Context, interval time.Duration, immediate bool, condition ConditionWithContextFunc) error
```

åå‰ã®é€šã‚Šæ¸¡ã•ã‚ŒãŸ Context ãŒ cancel ã•ã‚Œã‚‹ã¾ã§ã€ã‚‚ã—ãã¯ condition ã®é–¢æ•°ãŒ true ã‚’è¿”ã™ã¾ã§å¾…ã¡ç¶šã‘ã‚‹é–¢æ•°ã§ã™ã€‚
interval ã¯å®Ÿè¡Œé–“éš”ã€immediate ã¯æœ€åˆã® interval ã‚’å¾…ã¤ã‹ã©ã†ã‹ã‚’è¨­å®šã§ãã¾ã™ã€‚
ã¾ãŸ immediate ãŒ true ã®å ´åˆã¯ condition ã¯æœ€ä½ã§ã‚‚ä¸€åº¦ã¯å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

Pod ãŒå‰Šé™¤ã•ã‚Œã‚‹ã¾ã§å¾…ã¤ã‚ˆã†ãªã‚±ãƒ¼ã‚¹ã§ã¯æ™®é€šã«æ›¸ãã¨ select ã§ ctx.Done ã‚’ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãå¿…è¦ãŒã‚ã‚‹ã¨æ€ã„ã¾ã™ã€‚

```go
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

for {
  select {
  case <-ctx.Done():
    err := ctx.Err()
    if err != nil {
      fmt.Printf("Polling failed: %v\n", err)
    }
    return
  default:
    pod, err := k8sClient.Get(ctx, client.ObjectKey{ Name:podName, Namespace:namespace })
    if apierrors.IsNotFound(err) {
      fmt.Println("Pod has been deleted")
      return
    }
    if err != nil {
      fmt.Printf("Polling failed: %v\n", err)
      return
    }
    time.Sleep(5 * time.Second)
  }
}
```

`PollUntilContextCancel` ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã“ã‚“ãªæ„Ÿã˜ã§æ›¸ã‘ã¾ã™ã€‚

```go
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

_ := wait.PollUntilContextCancel(ctx, 5*time.Second, func(ctx context.Context) (bool, error) {
  _, err := k8sClient.Get(ctx, client.ObjectKey{ Name:podName, Namespace:namespace })
  if apierrors.IsNotFound(err) {
    fmt.Println("Pod has been deleted")
    return true, nil
  }
  if err != nil {
    fmt.Printf("Polling failed: %v\n", err)
    return false, err
  }
  return false, nil
})
```

## PollUntilContextTimeout

```go
func PollUntilContextTimeout(ctx context.Context, interval, timeout time.Duration, immediate bool, condition ConditionWithContextFunc) error
```

ä¼¼ãŸã‚ˆã†ãªé–¢æ•°ã§ Timeout ã‚’ãƒãƒ³ãƒ‰ãƒ«ã™ã‚‹ã‚‚ã®ã‚‚ã‚ã‚Šã¾ã™ãŒã€ã“ã‚Œã¯ context.WithTimeout ã‚’ä½¿ã£ã¦ã„ãªã„äººã®ãŸã‚ã®ã‚‚ã®ã§ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¨ç­‰ä¾¡ãªã®ã§åŸºæœ¬çš„ã«ã¯ `PollUntilContextCancel` ã‚’ä½¿ç”¨ã™ã‚‹ã®ãŒè‰¯ã„ã¨æ€ã„ã¾ã™ã€‚

```go
deadlineCtx, deadlineCancel := context.WithTimeout(ctx, timeout)
err := PollUntilContextCancel(deadlineCtx, interval, immediate, condition)
```

# Backoff

wait package ã§ã¯ backoff ã‚’ç°¡å˜ã«è¡Œã†ãŸã‚ã®é–¢æ•°ã‚‚æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚

backoff ã¨ã¯å¤±æ•—ã—ãŸæ™‚ã«å°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚„ã‚Šç›´ã™ä»•çµ„ã¿ã®ã“ã¨ã§ã€å¤±æ•—ãŒç¶šãã»ã©å¾…ã¡æ™‚é–“ã‚’é•·ãã—ã¦ã„ãæŒ‡æ•°é–¢æ•°çš„ Backoff(Exponential Backoff) ãŒã‚ˆãçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚

Backoff ã‚’è¡Œã†ãŸã‚ã®é–¢æ•°ã«ã¯ BackoffManager ã¨ã„ã†å¼•æ•°ãŒã‚ã‚Šã€ä»¥ä¸‹ã®ã‚ˆã†ã« 

```go
type BackoffManager interface {
	// Backoff returns a shared clock.Timer that is Reset on every invocation. This method is not
	// safe for use from multiple threads. It returns a timer for backoff, and caller shall backoff
	// until Timer.C() drains. If the second Backoff() is called before the timer from the first
	// Backoff() call finishes, the first timer will NOT be drained and result in undetermined
	// behavior.
	Backoff() clock.Timer
}

type Backoff struct {
	// The initial duration.
	Duration time.Duration
	// Duration is multiplied by factor each iteration, if factor is not zero
	// and the limits imposed by Steps and Cap have not been reached.
	// Should not be negative.
	// The jitter does not contribute to the updates to the duration parameter.
	Factor float64
	// The sleep at each iteration is the duration plus an additional
	// amount chosen uniformly at random from the interval between
	// zero and `jitter*duration`.
	Jitter float64
	// The remaining number of iterations in which the duration
	// parameter may change (but progress can be stopped earlier by
	// hitting the cap). If not positive, the duration is not
	// changed. Used for exponential backoff in combination with
	// Factor and Cap.
	Steps int
	// A limit on revised values of the duration parameter. If a
	// multiplication by the factor parameter would make the duration
	// exceed the cap then the duration is set to the cap and the
	// steps parameter is set to zero.
	Cap time.Duration
}
```

# ã¾ã¨ã‚

wait ã‚’ä½¿ã†ã“ã¨ã§ Polling ã®å‡¦ç†ã‚’ç°¡æ½”ã«æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€ãœã²ä½¿ã£ã¦ã¿ã¦ãã ã•ã„ã€‚

ã¨ã‚Šã‚ãˆãšæ°—åŠ›ã§ Polling ã®éƒ¨åˆ†ã ã‘æ›¸ãã¾ã—ãŸã€Backoff ã‚„ Until ã‚‚å¾Œã»ã©è¿½è¨˜ã—ã¾ã™ã€‚
