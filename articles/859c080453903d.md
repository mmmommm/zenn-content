---
title: "k8s.io/apimachinery/pkg/util/sets ã®ä½¿ã„é“"
emoji: "ğŸ‘‹"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Go", "Kubernetes"]
published: true
---

sets ãŒä¾¿åˆ©ãªã®ã§ä½¿ã„ã¾ã—ã‚‡ã†ï¼

https://pkg.go.dev/k8s.io/apimachinery/pkg/util/sets

Set ã¯ slice ã®ã‚ˆã†ãªæ¦‚å¿µã§ã™ãŒã€å†…éƒ¨çš„ã«ã¯ map ãªã®ã§è¦ç´ ã®é‡è¤‡ã¯è¨±ã•ã‚Œã¦ãŠã‚‰ãšã€ãã®ãŸã‚è¦ç´ ã®è¿½åŠ ã‚„å‰Šé™¤ã€å­˜åœ¨ç¢ºèªãªã©ã‚’çŸ­ã„æ™‚é–“ã§è¡Œãˆã¾ã™ã€‚
é›†åˆã®å’Œé›†åˆ(Union)ã€å·®é›†åˆ(Difference)ã€äº¤å·®(Intersection)ã€å¯¾ç§°å·®(Symmetric Difference)ãªã©æ•°å­¦çš„ãªé›†åˆæ¼”ç®—ãŒçµ„ã¿è¾¼ã¿ã§æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚
ã‚‚ã¡ã‚ã‚“ Insert ã‚„ Delete ã€Equal ã€ Clear ã€ Clone ã€ Len ãªã©ã®ä¸€èˆ¬çš„ãªæ“ä½œã‚’ã™ã‚‹ãŸã‚ã®é–¢æ•°ã¯ç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚
ã¾ãŸ UnsortedList ã® method ãŒã‚ã‚‹ãŸã‚æœ€çµ‚çš„ãªçµæœã‚’ slice ã«ã—ã¦è¿”å´ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚

ä»Šå›ã¯ sets ç´¹ä»‹ã—ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚

å‹çš„ã«ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚

```go
type Empty struct{}
type Set[T comparable] map[T]Empty
```

# New

```go
func New[T comparable](items ...T) Set[T]
```

èª¬æ˜ä¸è¦ã§ã™ã­ã€æ–°ãŸãª Set ã‚’è¿”ã™é–¢æ•°ã§ã™ã€‚
æ³¨æ„ç‚¹ã¨ã—ã¦ã¯ `sets.NewString()` ãªã©ã®å‹ã‚’æŒ‡å®šã—ã¦ä½œæˆã™ã‚‹é–¢æ•°ã¯ Deprecated ã«ãªã£ã¦ã„ã‚‹ãŸã‚ã€å‹ã‚’æŒ‡å®šã—ã¦å…¨ã¦ `sets.New()` ã§ä½œæˆã—ã¦ãã ã•ã„ã€‚

```go: deprecated
s := sets.NewString()
```

ã§ã¯ãªã

```go
s := sets.New[string]()
```

ã®ã‚ˆã†ã«ã—ã¦ä½œæˆã—ã¦ãã ã•ã„ã€‚

# Union

```go
func (s1 Set[T]) Union(s2 Set[T]) Set[T]
```

s1 ã¨ s2 ã®å’Œé›†åˆï¼ˆå…¨ã¦ï¼‰ã‚’è¿”ã™é–¢æ•°ã§ã™ã€‚

# Difference

```go
func (s1 Set[T]) Difference(s2 Set[T]) Set[T]
```

s1 ã¨ s2 ã®å·®é›†åˆï¼ˆs1 ã ã‘ã«å«ã¾ã‚Œ s2ã€€ã«ã¯å«ã¾ã‚Œãªã„ã‚‚ã®ï¼‰ã‚’è¿”ã™é–¢æ•°ã§ã™ã€‚

# Intersection

```go
func (s1 Set[T]) Intersection(s2 Set[T]) Set[T]
```

s1 ã¨ s2 ã®å…±é€šéƒ¨åˆ†(s1 ã«ã‚‚ s2 ã«ã‚‚å«ã¾ã‚Œã‚‹ã‚‚ã®)ã‚’è¿”ã™é–¢æ•°ã§ã™ã€‚

# SymmetricDifference

```go
func (s1 Set[T]) SymmetricDifference(s2 Set[T]) Set[T]
```

## Example

é–¢æ•°ã®èª¬æ˜ã¯ [Doc](https://pkg.go.dev/k8s.io/apimachinery/pkg/util/sets) ã‚’èª­ã‚ã°è‰¯ã„ã¨æ€ã†ã®ã§ã“ã“ã‹ã‚‰ã¯ä½¿ç”¨ä¾‹ã‚’ç´¹ä»‹ã—ã¦ã„ã“ã†ã¨æ€ã„ã¾ã™ã€‚

### å­˜åœ¨ã—ã¦ã„ã‚‹ã‹ã‚’åˆ¤å®šã™ã‚‹

ä¾‹ãˆã° `Has` ã‚’ç”¨ã„ã¦ map ã®ã‚ˆã†ã«æŒ‡å®šã™ã‚‹å€¤ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹å‡¦ç†ã‚’æ›¸ãç›´ã›ã¾ã™ã€‚

```go: sets ã‚’ä½¿ç”¨ã—ãªã„æ–¹æ³•
disallowedEnvs := map[string]struct{}{
  "RESERVED": {},
}
var pod corev1.Pod
_ := k8sClient.Get(context.Background(), client.ObjectKeyFromObject(hoge), &pod)
for i, container := range pod.Spec.Containers {
  for k, env := range container.Env {
    if _, exists := disallowedEnvs[env.Name]; exists {
      var envList []string
      for env := range disallowedEnvs {
        envList = append(envList, env)
      }
      return field.Invalid(field.NewPath("spec", "containers").Index(i).Child("env").Index(k).Child("name"), env.Name, fmt.Sprintf("must not be same as %v", envList))
    }
  }
}
```

```go: sets ã‚’ä½¿ç”¨ã—ãŸæ–¹æ³•
disallowedEnvs := sets.New("RESERVED")
var pod corev1.Pod
_ := k8sClient.Get(context.Background(), client.ObjectKeyFromObject(hoge), &pod)
for i, container := range pod.Spec.Containers {
  for k, env := range container.Env {
    if disallowedEnvs.Has(env.Name) {
      return field.Invalid(field.NewPath("spec", "containers").Index(i).Child("env").Index(k).Child("name"), env.Name, fmt.Sprintf("must not be same as %v", disallowedEnvs.UnsortedList()))
    }
  }
}
```

### äºŒé‡ãƒ«ãƒ¼ãƒ—ã‚’å›é¿ã™ã‚‹

Go ã§ for ã®äºŒé‡ãƒ«ãƒ¼ãƒ—ã‚’å›é¿ã™ã‚‹ãŸã‚ã« map ã«å…¥ã‚Œç›´ã™ã‚±ãƒ¼ã‚¹ã¯ã‚ˆãã‚ã‚‹ã¨æ€ã„ã¾ã™ã€‚
sets ã‚’ä½¿ç”¨ã™ã‚‹ã¨ `make(map[string]struct{})` ã®ã‚ˆã†ãªè¬ã® map ã‚’æ›¸ã‹ãšã«ç°¡æ½”ã«æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚

```go: for ã®äºŒé‡ãƒ«ãƒ¼ãƒ—
list1 := []string{"a", "b", "c"}
list2 := []string{"b", "c", "d"}
var common []string
for _, item1 := range list1 {
  for _, item2 := range list2 {
    if item1 == item2 {
      common = append(common, item1)
      break
    }
  }
}
// common = ["b", "c"]
```

```go: map[string]struct{} ã‚’ä½¿ç”¨ã™ã‚‹æ–¹æ³•
list1 := []string{"a", "b", "c"}
list2 := []string{"b", "c", "d"}
set := make(map[string]struct{})
for _, item := range list1 {
  set[item] = struct{}{}
}
var common []string
for _, item := range list2 {
  if _, exists := set[item]; exists {
    common = append(common, item)
  }
}
// common = ["b", "c"]
```

```go: sets ã‚’ä½¿ç”¨ã—ãŸæ–¹æ³•1
list1 := []string{"a", "b", "c"}
list2 := []string{"b", "c", "d"}
s := sets.New(list1...)
commons := sets.New[string]()
for _, item := range list2 {
  if s.Has(item) {
    common.Insert(item)
  }
}

common := commons.UnsortedList()
// common = ["b", "c"]
```

```go: sets ã‚’ä½¿ç”¨ã—ãŸæ–¹æ³•2
list1 := []string{"a", "b", "c"}
list2 := []string{"b", "c", "d"}
common := sets.New(list1...).Intersection(sets.New(list2...)).UnsortedList()
// common = ["b", "c"]
```


# ã¾ã¨ã‚

å…¨ã¦ã®é–¢æ•°ã®ä¾‹ã‚’ç¤ºã™ã“ã¨ã¯ã§ãã¦ã„ã¾ã›ã‚“ãŒ `sets` ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€slice ã®æ“ä½œæ™‚ã«ã‚ˆã‚Šæ„å›³ãŒæ˜ç¢ºã«ãªã‚Šã€ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§ãŒå‘ä¸Šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ã‚µãƒ¼ãƒ“ã‚¹å´ã§è¨±å¯ã—ã¦ã„ã‚‹ï¼ˆã—ã¦ã„ãªã„ï¼‰å€¤ãŒã‚ã‚Šãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®å€¤ã‚’ç¢ºèªã—ã¦ãƒã‚§ãƒƒã‚¯ã™ã‚‹å ´åˆã‚„ã€è¤‡æ•°ã®é…åˆ—ã‚’æ“ä½œã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆãªã©ã«ä½¿ç”¨ã™ã‚‹ã¨åŠ›ã‚’æ„Ÿã˜ã‚‰ã‚Œã‚‹ã¨æ€ã„ã¾ã™ã€‚

ãœã² `sets` ã‚’ä½¿ç”¨ã—ã¦ã¿ã¦ãã ã•ã„ï¼


